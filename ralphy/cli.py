"""CLI interface for Ralphy."""

import re
import sys
from importlib import resources
from pathlib import Path

import click
from rich.console import Console
from rich.table import Table

from ralphy import __version__
from ralphy.claude import (
    abort_running_claude,
    check_claude_installed,
    check_gh_installed,
    check_git_installed,
)
from ralphy.config import get_feature_dir, load_config
from ralphy.logger import get_logger
from ralphy.orchestrator import Orchestrator
from ralphy.constants import FEATURE_NAME_PATTERN
from ralphy.state import Phase, StateManager


def description_to_feature_name(description: str, max_length: int = 50) -> str:
    """Convert a description string to a valid feature name slug.

    Args:
        description: The feature description (e.g., "implement auth with devise")
        max_length: Maximum length for the slug (default 50)

    Returns:
        A valid feature name slug (e.g., "implement-auth-with-devise")

    Raises:
        ValueError: If the description cannot be converted to a valid feature name
    """
    import unicodedata

    if not description or not description.strip():
        raise ValueError("Cannot derive valid feature name from empty description")

    # Normalize unicode, lowercase, replace non-alphanumeric with hyphens
    slug = unicodedata.normalize("NFKD", description)
    slug = slug.encode("ascii", "ignore").decode("ascii").lower()
    slug = re.sub(r"[^a-z0-9]+", "-", slug).strip("-")
    slug = re.sub(r"-+", "-", slug)

    # Truncate without breaking mid-word
    if len(slug) > max_length:
        slug = slug[:max_length].rsplit("-", 1)[0]

    if not slug or not FEATURE_NAME_PATTERN.match(slug):
        raise ValueError(f"Cannot derive valid feature name from: {description}")

    return slug


def generate_quick_prd(description: str) -> str:
    """Generate minimal PRD.md content from a description.

    Args:
        description: The feature description

    Returns:
        PRD markdown content
    """
    return f"""# {description.strip()}

## Objective

{description.strip()}

## Requirements

Implement the feature as described above.

---
*Generated by Ralphy Quick Start mode*
"""


# List of prompt files to copy
PROMPT_FILES = [
    "spec_agent.md",
    "dev_prompt.md",
    "qa_agent.md",
    "pr_agent.md",
]


def _generate_prompt_header(prompt_file: str) -> str:
    """Generates a header documenting available placeholders for a prompt.

    Args:
        prompt_file: Prompt file name (e.g., spec_agent.md)

    Returns:
        Markdown header with placeholder documentation.
    """
    # Placeholders common to all prompts
    common_placeholders = """
| Placeholder | Description |
|-------------|-------------|
| `{{project_name}}` | Project name |
| `{{language}}` | Tech stack (from config.yaml) |
| `{{test_command}}` | Test command (from config.yaml) |
"""

    # Agent-specific placeholders
    specific_placeholders = {
        "spec_agent.md": """| `{{prd_content}}` | Content of PRD.md |
""",
        "dev_prompt.md": """| `{{spec_content}}` | Content of SPEC.md |
| `{{tasks_content}}` | Content of TASKS.md |
| `{{resume_instruction}}` | Resume instructions (empty if new session) |
| `{{orchestration_section}}` | Agent orchestration instructions (if agents exist) |
""",
        "qa_agent.md": """| `{{spec_content}}` | Content of SPEC.md |
""",
        "pr_agent.md": """| `{{branch_name}}` | Branch name to create |
| `{{qa_report}}` | QA report content |
| `{{spec_content}}` | Content of SPEC.md |
""",
    }

    # Extract agent name from filename
    agent_name = prompt_file.replace("_agent.md", "").replace("_prompt.md", "").replace("_", " ").title()
    specific = specific_placeholders.get(prompt_file, "")

    return f"""<!--
=============================================================================
CUSTOM PROMPT TEMPLATE - {agent_name} Agent
=============================================================================

This file is a custom prompt template for Ralphy.
Modify it to adapt agent behavior to your stack/project.

IMPORTANT: This prompt MUST contain the "EXIT_SIGNAL" instruction so
the agent can signal the end of its execution.

Available placeholders (replaced automatically at runtime):
{common_placeholders}{specific}
Documentation: https://github.com/your-org/ralphy#custom-prompts
=============================================================================
-->

"""


def _generate_config_template() -> str:
    """Generate config.yaml template with default values and documentation.

    Returns:
        A YAML string with all config sections, default values, and comments.
    """
    from ralphy.constants import (
        SPEC_TIMEOUT_SECONDS,
        IMPL_TIMEOUT_SECONDS,
        QA_TIMEOUT_SECONDS,
        PR_TIMEOUT_SECONDS,
        AGENT_TIMEOUT_SECONDS,
        DEFAULT_RETRY_ATTEMPTS,
        DEFAULT_RETRY_DELAY_SECONDS,
        CB_INACTIVITY_TIMEOUT_SECONDS,
        CB_MAX_REPEATED_ERRORS,
        CB_TASK_STAGNATION_TIMEOUT_SECONDS,
        CB_MAX_OUTPUT_SIZE_BYTES,
        CB_MAX_ATTEMPTS,
    )

    return f"""# =============================================================================
# RALPHY CONFIGURATION
# =============================================================================
# This file configures Ralphy's behavior for this project.
# All values shown are defaults. Only override what you need to change.
#
# Documentation: https://github.com/ThibautBaissac/Ralphy#configuration
# =============================================================================

# -----------------------------------------------------------------------------
# Project Settings
# -----------------------------------------------------------------------------
project:
  name: my-project  # Project name used in agent prompts

# -----------------------------------------------------------------------------
# Model Configuration
# -----------------------------------------------------------------------------
# Claude model to use for each phase. Options: sonnet, opus, haiku
# or full model names like claude-sonnet-4-5-20250929
models:
  specification: sonnet  # Spec generation (balanced)
  implementation: sonnet  # Code implementation (most capable recommended)
  qa: sonnet             # Quality analysis (balanced)
  pr: sonnet             # PR creation (fast is fine)

# -----------------------------------------------------------------------------
# Tech Stack
# -----------------------------------------------------------------------------
stack:
  language: typescript     # Primary language/framework
  test_command: npm test   # Command to run tests
  tdd_enabled: true        # Enable TDD mode (run tests after each task)

# -----------------------------------------------------------------------------
# Timeouts (seconds)
# -----------------------------------------------------------------------------
timeouts:
  specification: {SPEC_TIMEOUT_SECONDS}   # 30 min - Spec generation
  implementation: {IMPL_TIMEOUT_SECONDS}  # 4h - Code implementation
  qa: {QA_TIMEOUT_SECONDS}              # 30 min - QA analysis
  pr: {PR_TIMEOUT_SECONDS}               # 10 min - PR creation
  agent: {AGENT_TIMEOUT_SECONDS}              # 5 min - Fallback timeout

# -----------------------------------------------------------------------------
# Retry Configuration
# -----------------------------------------------------------------------------
retry:
  max_attempts: {DEFAULT_RETRY_ATTEMPTS}       # Total attempts (1 = no retry)
  delay_seconds: {DEFAULT_RETRY_DELAY_SECONDS}      # Delay between retries

# -----------------------------------------------------------------------------
# Circuit Breaker - Protection against infinite loops
# -----------------------------------------------------------------------------
circuit_breaker:
  enabled: true
  inactivity_timeout: {CB_INACTIVITY_TIMEOUT_SECONDS}     # Seconds without output before warning
  max_repeated_errors: {CB_MAX_REPEATED_ERRORS}      # Same error count before warning
  task_stagnation_timeout: {CB_TASK_STAGNATION_TIMEOUT_SECONDS}  # Seconds without task completion (dev-agent)
  max_output_size: {CB_MAX_OUTPUT_SIZE_BYTES}    # Max cumulative output in bytes (500KB)
  max_attempts: {CB_MAX_ATTEMPTS}            # Warnings before circuit trips
"""


console = Console()


@click.group()
@click.version_option(version=__version__, prog_name="ralphy")
def main():
    """Ralphy - Transforms a PRD into a Pull Request."""
    pass


@main.command()
@click.argument("feature_or_description", type=str)
@click.option("--no-progress", is_flag=True, help="Disable progress display")
@click.option("--fresh", is_flag=True, help="Force a full restart without resume")
def start(feature_or_description: str, no_progress: bool, fresh: bool):
    """Starts a Ralphy workflow for a feature.

    FEATURE_OR_DESCRIPTION: Either a feature name (ex: user-authentication) or a
    feature description in quotes (ex: "implement auth with devise")

    Normal mode (feature name):
        The PRD.md must exist in docs/features/<feature-name>/PRD.md

    Quick start mode (description):
        If the input doesn't match an existing feature with PRD.md, Ralphy will:
        - Derive a feature name from the description
        - Create the feature directory
        - Generate a minimal PRD.md
        - Run the full workflow

    By default, if the workflow was interrupted, it will resume from the
    last completed phase. Use --fresh to force a complete restart.
    """
    project = Path.cwd()
    logger = get_logger()
    show_progress = not no_progress

    # Preliminary checks
    if not check_claude_installed():
        logger.error("Claude Code CLI not found. Install it with: npm install -g @anthropic-ai/claude-code")
        sys.exit(1)

    if not check_git_installed():
        logger.error("Git not found. Install Git: https://git-scm.com/")
        sys.exit(1)

    if not check_gh_installed():
        logger.error("GitHub CLI (gh) not found. Install it: https://cli.github.com/")
        sys.exit(1)

    # Determine if this is quick start mode or normal mode
    is_quick_start = False
    feature_name = feature_or_description

    if FEATURE_NAME_PATTERN.match(feature_or_description):
        # Looks like a valid feature name - check if PRD exists
        feature_dir = get_feature_dir(project, feature_or_description)
        if not (feature_dir / "PRD.md").exists():
            # No PRD exists, treat as quick start
            is_quick_start = True
    else:
        # Not a valid feature name pattern, treat as description (quick start)
        is_quick_start = True

    if is_quick_start:
        # Quick start mode: derive feature name from description
        try:
            feature_name = description_to_feature_name(feature_or_description)
        except ValueError as e:
            logger.error(str(e))
            sys.exit(1)

        feature_dir = get_feature_dir(project, feature_name)
        prd_path = feature_dir / "PRD.md"

        # Check if the derived feature name conflicts with an existing feature
        if prd_path.exists():
            logger.warn(f"Feature '{feature_name}' already exists with a PRD.md")
            logger.info("Using existing PRD.md instead of generating a new one")
        else:
            # Create feature directory and generate PRD
            feature_dir.mkdir(parents=True, exist_ok=True)
            prd_content = generate_quick_prd(feature_or_description)
            prd_path.write_text(prd_content, encoding="utf-8")
            logger.info(f"Quick start: created {prd_path}")
    else:
        # Normal mode: feature name with existing PRD
        feature_dir = get_feature_dir(project, feature_name)
        prd_path = feature_dir / "PRD.md"
        if not prd_path.exists():
            logger.error(f"PRD.md not found in {feature_dir}")
            logger.error(f"Create {prd_path} with your feature requirements")
            sys.exit(1)

    # V√©rifie si un workflow est d√©j√† en cours
    state_manager = StateManager(project, feature_name)
    if state_manager.is_running():
        logger.warn(f"Un workflow est d√©j√† en cours (phase: {state_manager.state.phase.value})")
        if not click.confirm("Voulez-vous le r√©initialiser ?", default=False):
            sys.exit(0)
        state_manager.reset()

    # Lance l'orchestrateur
    logger.info(f"D√©marrage du workflow pour: {feature_name}")
    logger.newline()

    orchestrator = Orchestrator(project, feature_name=feature_name, show_progress=show_progress)
    success = orchestrator.run(fresh=fresh)

    sys.exit(0 if success else 1)


@main.command()
@click.argument("feature_name", type=str, required=False)
@click.option("--all", "show_all", is_flag=True, help="Affiche le statut de toutes les features")
def status(feature_name: str = None, show_all: bool = False):
    """Affiche le statut du workflow.

    FEATURE_NAME: Nom de la feature (requis sauf si --all)
    """
    project = Path.cwd()
    logger = get_logger()

    if show_all:
        # Show status for all features
        features_dir = project / "docs" / "features"
        if not features_dir.exists():
            console.print("[yellow]No features found.[/yellow]")
            console.print(f"[dim]Create a feature with: mkdir -p docs/features/<feature-name> && touch docs/features/<feature-name>/PRD.md[/dim]")
            return

        features = [d.name for d in features_dir.iterdir() if d.is_dir()]
        if not features:
            console.print("[yellow]No features found.[/yellow]")
            return

        table = Table(title="Ralphy Features Status")
        table.add_column("Feature", style="cyan")
        table.add_column("Phase", style="green")
        table.add_column("Progress", style="blue")
        table.add_column("Last Completed", style="dim")

        for fname in sorted(features):
            state_manager = StateManager(project, fname)
            state = state_manager.state

            phase_style = "green"
            if state.phase in (Phase.FAILED, Phase.REJECTED):
                phase_style = "red"
            elif state.phase in (Phase.AWAITING_SPEC_VALIDATION, Phase.AWAITING_QA_VALIDATION):
                phase_style = "yellow"

            progress = f"{state.tasks_completed}/{state.tasks_total}" if state.tasks_total > 0 else "-"
            last_completed = state.last_completed_phase or "-"

            table.add_row(
                fname,
                f"[{phase_style}]{state.phase.value}[/{phase_style}]",
                progress,
                last_completed,
            )

        console.print(table)
        return

    # Single feature status
    if not feature_name:
        logger.error("Feature name required. Use --all to show all features.")
        sys.exit(1)

    # Validate feature name
    if not FEATURE_NAME_PATTERN.match(feature_name):
        logger.error(f"Invalid feature name: {feature_name}")
        sys.exit(1)

    state_manager = StateManager(project, feature_name)
    state = state_manager.state

    table = Table(title=f"Statut Ralphy - {feature_name}")
    table.add_column("Propri√©t√©", style="cyan")
    table.add_column("Valeur", style="green")

    # Style selon la phase
    phase_style = "green"
    if state.phase in (Phase.FAILED, Phase.REJECTED):
        phase_style = "red"
    elif state.phase in (Phase.AWAITING_SPEC_VALIDATION, Phase.AWAITING_QA_VALIDATION):
        phase_style = "yellow"

    table.add_row("Phase", f"[{phase_style}]{state.phase.value}[/{phase_style}]")
    table.add_row("Statut", state.status.value)

    if state.started_at:
        table.add_row("D√©marr√©", state.started_at)

    if state.tasks_total > 0:
        progress = f"{state.tasks_completed}/{state.tasks_total}"
        table.add_row("T√¢ches", progress)

    if state.last_completed_phase:
        table.add_row("Derni√®re phase compl√©t√©e", f"[cyan]{state.last_completed_phase}[/cyan]")

    if state.error_message:
        table.add_row("Erreur", f"[red]{state.error_message}[/red]")

    console.print(table)

    # Hint pour red√©marrer si le workflow est termin√© en √©chec
    if state.phase in (Phase.FAILED, Phase.REJECTED):
        console.print()
        if state.last_completed_phase:
            console.print(
                f"[dim]üí° Pour reprendre le workflow: [cyan]ralphy start {feature_name}[/cyan][/dim]"
            )
            console.print(
                f"[dim]üí° Pour red√©marrer de z√©ro: [cyan]ralphy start {feature_name} --fresh[/cyan][/dim]"
            )
        else:
            console.print(
                f"[dim]üí° Pour relancer le workflow: [cyan]ralphy start {feature_name}[/cyan][/dim]"
            )


@main.command()
@click.argument("feature_name", type=str)
def abort(feature_name: str):
    """Abort le workflow en cours.

    FEATURE_NAME: Nom de la feature
    """
    project = Path.cwd()
    logger = get_logger()

    # Validate feature name
    if not FEATURE_NAME_PATTERN.match(feature_name):
        logger.error(f"Invalid feature name: {feature_name}")
        sys.exit(1)

    state_manager = StateManager(project, feature_name)

    # V√©rifie si le workflow est actif (running ou en attente de validation)
    if not state_manager.is_running() and not state_manager.is_awaiting_validation():
        logger.warn("Aucun workflow en cours")
        return

    # Interrompt le process Claude s'il est en cours (pas de process pendant validation)
    if state_manager.is_running():
        abort_running_claude(project)

    state_manager.set_failed("Avort√© par l'utilisateur")
    logger.info("Workflow avort√©")


@main.command()
@click.argument("feature_name", type=str)
def reset(feature_name: str):
    """R√©initialise l'√©tat du workflow.

    FEATURE_NAME: Nom de la feature
    """
    project = Path.cwd()
    logger = get_logger()

    # Validate feature name
    if not FEATURE_NAME_PATTERN.match(feature_name):
        logger.error(f"Invalid feature name: {feature_name}")
        sys.exit(1)

    state_manager = StateManager(project, feature_name)

    if click.confirm(f"R√©initialiser l'√©tat du workflow pour {feature_name} ?", default=False):
        state_manager.reset()
        logger.info("√âtat r√©initialis√©")


@main.command("init-prompts")
@click.argument("project_path", type=click.Path(exists=True, file_okay=False, resolve_path=True), required=False)
@click.option("--force", is_flag=True, help="√âcrase les prompts existants")
def init_prompts(project_path: str = None, force: bool = False):
    """Initialise les templates de prompts personnalis√©s.

    Copie les templates de prompts par d√©faut dans .ralphy/prompts/ du projet.
    Ces templates peuvent ensuite √™tre modifi√©s pour adapter Ralphy √† votre stack.

    PROJECT_PATH: Chemin vers le projet (d√©faut: r√©pertoire courant)

    Utilisez --force pour √©craser les prompts existants.
    """
    project = Path(project_path) if project_path else Path.cwd()
    logger = get_logger()

    # Cr√©e le r√©pertoire .ralphy/prompts/ s'il n'existe pas
    prompts_dir = project / ".ralphy" / "prompts"
    prompts_dir.mkdir(parents=True, exist_ok=True)

    copied = 0
    skipped = 0

    for prompt_file in PROMPT_FILES:
        dest_path = prompts_dir / prompt_file

        # Skip si fichier existe et pas --force
        if dest_path.exists() and not force:
            logger.warn(f"Skipping {prompt_file} (exists, use --force to overwrite)")
            skipped += 1
            continue

        # Charge le contenu depuis le package
        try:
            original_content = resources.files("ralphy.prompts").joinpath(prompt_file).read_text(encoding="utf-8")
        except (FileNotFoundError, TypeError):
            logger.error(f"Template {prompt_file} not found in package")
            continue

        # Ajoute le header documentant les placeholders
        header = _generate_prompt_header(prompt_file)
        content = header + original_content

        # √âcrit le fichier
        dest_path.write_text(content, encoding="utf-8")
        logger.info(f"Created {prompt_file}")
        copied += 1

    # R√©sum√©
    console.print()
    if copied > 0:
        console.print(f"[green]‚úì[/green] {copied} prompt(s) copied to {prompts_dir}")
    if skipped > 0:
        console.print(f"[yellow]![/yellow] {skipped} prompt(s) skipped (use --force to overwrite)")

    if copied > 0:
        console.print()
        console.print("[dim]Edit these files to customize Ralphy for your project.[/dim]")
        console.print("[dim]Remember: prompts must contain EXIT_SIGNAL instruction.[/dim]")


@main.command("init-config")
@click.argument("project_path", type=click.Path(exists=True, file_okay=False, resolve_path=True), required=False)
@click.option("--force", is_flag=True, help="Overwrite existing config file")
def init_config(project_path: str = None, force: bool = False):
    """Initialize a default configuration file.

    Creates a .ralphy/config.yaml file with all default values and documentation
    comments. This file can be customized to adjust timeouts, models, and other
    settings for your project.

    PROJECT_PATH: Path to the project (default: current directory)

    Use --force to overwrite an existing config file.
    """
    project = Path(project_path) if project_path else Path.cwd()
    logger = get_logger()

    # Create .ralphy/ directory if it doesn't exist
    ralphy_dir = project / ".ralphy"
    ralphy_dir.mkdir(parents=True, exist_ok=True)

    config_path = ralphy_dir / "config.yaml"

    # Check if config already exists
    if config_path.exists() and not force:
        logger.warn(f"Config file already exists: {config_path}")
        console.print("[dim]Use --force to overwrite.[/dim]")
        return

    # Generate and write config template
    template = _generate_config_template()
    config_path.write_text(template, encoding="utf-8")

    if config_path.exists():
        console.print(f"[green]‚úì[/green] Created {config_path}")
        console.print()
        console.print("[dim]Edit this file to customize Ralphy for your project.[/dim]")
        console.print("[dim]Only override values you need to change.[/dim]")
    else:
        logger.error(f"Failed to create config file: {config_path}")


if __name__ == "__main__":
    main()
